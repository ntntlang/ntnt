// Contract Example in Intent
// Demonstrates design-by-contract features

// A function with preconditions and postconditions
fn divide(a, b) -> Int
requires b != 0
ensures result * b == a
{
    return a / b;
}

// Safe division - the contract ensures we never divide by zero
let result = divide(10, 2);
print("10 / 2 = " + str(result));

// A transfer function with balance checking
fn transfer(amount, from_balance, to_balance)
requires amount > 0
requires from_balance >= amount
ensures result[0] == from_balance - amount
ensures result[1] == to_balance + amount
{
    let new_from = from_balance - amount;
    let new_to = to_balance + amount;
    return [new_from, new_to];
}

// Perform a transfer
let balances = transfer(50, 100, 75);
print("After transfer:");
print("  From balance: " + str(balances[0]));
print("  To balance: " + str(balances[1]));

// Struct with invariant (conceptual - full implementation coming)
struct Account {
    balance: Int
}

// The invariant would ensure balance is never negative
// impl Account {
//     invariant self.balance >= 0
// }

print("Contract examples completed successfully!");
