// Full Invariant Examples - Demonstrating invariant checking across all scenarios
// Phase 1: Core Contract System - Struct Invariants

// ============================================
// Example 1: BankAccount with balance invariant
// ============================================
print("=== Example 1: BankAccount Invariant ===")

struct BankAccount {
    balance: Int,
    owner: String
}

impl BankAccount {
    // Invariant: balance must never be negative
    invariant self.balance >= 0
    
    // Constructor function (not a method, used to create accounts)
    fn new(owner: String, initial_balance: Int) -> BankAccount {
        BankAccount { owner: owner, balance: initial_balance }
    }
}

// Create a valid account
let account = BankAccount { owner: "Alice", balance: 100 }
print("Account created with balance: " + account.balance)

// ============================================
// Example 2: Counter with bounds invariant  
// ============================================
print("\n=== Example 2: Bounded Counter ===")

struct BoundedCounter {
    value: Int,
    min: Int,
    max: Int
}

impl BoundedCounter {
    // Invariant: value must be within bounds
    invariant self.value >= self.min
    invariant self.value <= self.max
    
    fn new(min_val: Int, max_val: Int) -> BoundedCounter {
        BoundedCounter { value: min_val, min: min_val, max: max_val }
    }
}

let counter = BoundedCounter { value: 5, min: 0, max: 10 }
print("Counter created with value: " + counter.value)
print("Valid range: " + counter.min + " to " + counter.max)

// ============================================
// Example 3: NonEmptyList invariant
// ============================================
print("\n=== Example 3: NonEmptyList ===")

struct NonEmptyList {
    items: Array,
    length: Int
}

impl NonEmptyList {
    // Invariant: list must always have at least one item
    invariant self.length > 0
}

let list = NonEmptyList { items: [1, 2, 3], length: 3 }
print("List created with " + list.length + " items")

// ============================================  
// Example 4: Temperature with reasonable bounds
// ============================================
print("\n=== Example 4: Temperature (Kelvin) ===")

struct Temperature {
    kelvin: Int
}

impl Temperature {
    // Invariant: temperature in Kelvin cannot be negative (absolute zero)
    invariant self.kelvin >= 0
}

let temp = Temperature { kelvin: 293 }  // About 20Â°C
print("Temperature: " + temp.kelvin + " K")

// ============================================
// Example 5: Percentage value
// ============================================
print("\n=== Example 5: Percentage ===")

struct Percentage {
    value: Int
}

impl Percentage {
    // Invariant: percentage must be between 0 and 100
    invariant self.value >= 0
    invariant self.value <= 100
}

let progress = Percentage { value: 75 }
print("Progress: " + progress.value + "%")

// ============================================
// Example 6: Rectangle with positive dimensions
// ============================================
print("\n=== Example 6: Rectangle ===")

struct Rectangle {
    width: Int,
    height: Int
}

impl Rectangle {
    // Invariant: dimensions must be positive
    invariant self.width > 0
    invariant self.height > 0
}

let rect = Rectangle { width: 10, height: 5 }
print("Rectangle: " + rect.width + " x " + rect.height)

// ============================================
// Example 7: Ratio (fraction representation)
// ============================================
print("\n=== Example 7: Ratio ===")

struct Ratio {
    numerator: Int,
    denominator: Int
}

impl Ratio {
    // Invariant: denominator cannot be zero
    invariant self.denominator != 0
}

let half = Ratio { numerator: 1, denominator: 2 }
print("Ratio: " + half.numerator + "/" + half.denominator)

// ============================================
// Summary
// ============================================
print("\n=== All Invariant Examples Passed! ===")
print("Invariants are checked:")
print("  1. On struct construction (struct literals)")
print("  2. After method calls that modify self")
print("  3. After direct field assignments")
print("  4. Any violation stops execution with clear error")
